<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bamboo Garden Kitchen</title>
  <link rel="shortcut icon" href="bg_img.PNG" type="image/x-icon" />
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <!-- Animate.css -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <!-- Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bamboo-green: #4a7c59;
      --bamboo-light: #8fbc8f;
      --bamboo-dark: #2d4a35;
      --accent-gold: #ffd700;
      --bg-primary: #f8fffe;
      --shadow-light: 0 4px 20px rgba(74, 124, 89, 0.1);
      --shadow-medium: 0 8px 30px rgba(74, 124, 89, 0.15);
      --gradient-green: linear-gradient(135deg, #4a7c59 0%, #8fbc8f 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg-primary);
      font-family: 'Inter', sans-serif;
      line-height: 1.6;
      color: #2c3e50;
    }

    .navbar {
      background: var(--gradient-green) !important;
      box-shadow: var(--shadow-medium);
      padding: 1rem 0;
      backdrop-filter: blur(10px);
    }

    .navbar-brand {
      font-weight: 700;
      color: white !important;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .navbar-brand::before {
      content: 'üêº';
      font-size: 2rem;
    }

    .nav-link {
      color: rgba(255, 255, 255, 0.9) !important;
      font-weight: 500;
      transition: all 0.3s ease;
      padding: 0.75rem 1.25rem !important;
      border-radius: 25px;
      margin: 0 0.25rem;
    }

    .nav-link:hover, .nav-link.active {
      color: white !important;
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }

    .dashboard-header {
      background: var(--gradient-green);
      color: white;
      padding: 2rem 0;
      margin-bottom: 2rem;
      position: relative;
      overflow: hidden;
    }

    .dashboard-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M0,0 C20,20 40,0 60,20 C80,40 100,20 100,40 L100,100 L0,100 Z" fill="rgba(255,255,255,0.1)"/></svg>');
      background-size: 100px 100px;
    }

    .dashboard-title {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      position: relative;
      z-index: 2;
    }

    .dashboard-subtitle {
      font-size: 1.1rem;
      opacity: 0.9;
      position: relative;
      z-index: 2;
    }

    .order-card {
      background: white;
      border-radius: 20px;
      box-shadow: var(--shadow-light);
      padding: 2rem;
      margin-bottom: 1.5rem;
      border: 1px solid rgba(74, 124, 89, 0.1);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .order-card.new-order {
      border: 2px solid var(--accent-gold);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      animation: newOrderPulse 2s ease-in-out;
    }

    @keyframes newOrderPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .order-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: var(--gradient-green);
    }

    .order-card.new-order::before {
      background: var(--accent-gold);
      height: 6px;
    }

    .order-card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-medium);
    }

    .order-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .table-info {
      flex: 1;
    }

    .table-number {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--bamboo-dark);
      margin-bottom: 0.25rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .order-time {
      color: #6c757d;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .status-badge {
      font-size: 0.9rem;
      font-weight: 600;
      padding: 0.5rem 1rem;
      border-radius: 25px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .status-pending {
      background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
      color: #856404;
      border: 1px solid #ffeaa7;
    }

    .status-preparing {
      background: linear-gradient(135deg, #cff4fc 0%, #74c0fc 100%);
      color: #055160;
      border: 1px solid #74c0fc;
    }

    .status-ready {
      background: linear-gradient(135deg, #d1e7dd 0%, #75b798 100%);
      color: #0f5132;
      border: 1px solid #75b798;
    }

    .order-items {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .order-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 0;
      border-bottom: 1px solid #e9ecef;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .order-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .item-name {
      flex: 1;
      font-weight: 500;
      color: var(--bamboo-dark);
      min-width: 200px;
    }

    .item-quantity {
      background: var(--bamboo-light);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .item-price {
      font-weight: 600;
      color: var(--bamboo-dark);
      font-size: 1.1rem;
    }

    .order-total {
      background: var(--gradient-green);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 15px;
      margin-bottom: 1.5rem;
      text-align: center;
      font-weight: 700;
      font-size: 1.2rem;
      box-shadow: var(--shadow-light);
    }

    /* Button Container for proper alignment */
    .order-actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }

    .status-btn {
      background: var(--gradient-green);
      border: none;
      color: white;
      padding: 0.75rem 2rem;
      border-radius: 25px;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      flex: 1;
      min-width: 180px;
    }

    .status-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
      color: white;
    }

    .status-btn.preparing {
      background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);
    }

    .status-btn.ready {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    }

    .cancel-btn {
      background: linear-gradient(135deg, #ff5252 0%, #ffbaba 100%);
      border: none;
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 25px;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s ease;
      box-shadow: var(--shadow-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      flex-shrink: 0;
      min-width: 120px;
    }

    .cancel-btn:hover {
      background: linear-gradient(135deg, #c82333 0%, #ffbaba 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
    }

    .stats-row {
      background: white;
      border-radius: 20px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow-light);
    }

    .stat-card {
      text-align: center;
      padding: 1rem;
    }

    .stat-number {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--bamboo-green);
      display: block;
    }

    .stat-label {
      color: #6c757d;
      font-weight: 500;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 1px;
    }

    .bamboo-decoration {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 3rem;
      opacity: 0.3;
      z-index: 1;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .filter-tabs {
      background: white;
      border-radius: 15px;
      padding: 0.5rem;
      box-shadow: var(--shadow-light);
      margin-bottom: 2rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .filter-tab {
      flex: 1;
      min-width: 120px;
      padding: 0.75rem 1rem;
      border: none;
      background: transparent;
      border-radius: 12px;
      font-weight: 600;
      transition: all 0.3s ease;
      color: #6c757d;
    }

    .filter-tab.active {
      background: var(--gradient-green);
      color: white;
      box-shadow: var(--shadow-light);
    }

    .no-orders {
      text-align: center;
      padding: 4rem 2rem;
      background: white;
      border-radius: 20px;
      box-shadow: var(--shadow-light);
    }

    .no-orders-icon {
      font-size: 5rem;
      margin-bottom: 2rem;
      opacity: 0.3;
    }

    .new-order-alert {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--accent-gold);
      color: #856404;
      padding: 1rem 2rem;
      border-radius: 15px;
      box-shadow: var(--shadow-medium);
      z-index: 1000;
      font-weight: 600;
      animation: slideInRight 0.5s ease-out;
    }

    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .connection-status {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: #28a745;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
      z-index: 1001;
      box-shadow: var(--shadow-light);
      transition: opacity 0.5s;
    }

    .connection-status.error {
      background: #dc3545;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      .dashboard-title {
        font-size: 2rem;
      }
      
      .order-card {
        padding: 1rem;
        margin-bottom: 1rem;
      }
      
      .order-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }
      
      .item-name {
        min-width: auto;
        font-size: 1rem;
      }
      
      .order-items {
        padding: 1rem;
      }
      
      .stat-card {
        padding: 0.5rem;
      }
      
      .stat-number {
        font-size: 1.5rem;
      }
      
      .filter-tabs {
        flex-direction: column;
        gap: 0.25rem;
        padding: 0.5rem 0.25rem;
      }
      
      .filter-tab {
        min-width: unset;
        padding: 0.5rem 0.75rem;
        font-size: 0.95rem;
      }
      
      .no-orders {
        padding: 2rem 1rem;
      }

      /* Mobile Button Alignment */
      .order-actions {
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
      }

      .status-btn {
        flex: none;
        min-width: unset;
        width: 100%;
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
      }

      .cancel-btn {
        flex: none;
        min-width: unset;
        width: 100%;
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
      }

      #soundToggle {
        top: auto !important;
        bottom: 1rem !important;
        right: 1rem !important;
        left: auto !important;
        position: fixed !important;
        z-index: 1002 !important;
      }
    }

    /* Extra Small Mobile Screens */
    @media (max-width: 480px) {
      .order-card {
        padding: 0.75rem;
        border-radius: 15px;
      }

      .order-actions {
        gap: 0.4rem;
      }

      .status-btn, .cancel-btn {
        padding: 0.65rem 0.8rem;
        font-size: 0.9rem;
        border-radius: 20px;
      }

      .dashboard-title {
        font-size: 1.6rem;
      }

      .table-number {
        font-size: 1.2rem;
      }

      .order-total {
        padding: 0.8rem 1rem;
        font-size: 1.1rem;
      }
    }

    /* Very Small Screens */
    @media (max-width: 360px) {
      .order-card {
        padding: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .order-actions {
        gap: 0.3rem;
      }

      .status-btn, .cancel-btn {
        padding: 0.6rem 0.7rem;
        font-size: 0.85rem;
        border-radius: 18px;
      }

      .order-items {
        padding: 0.75rem;
      }

      .order-total {
        padding: 0.7rem;
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>

  <div class="dashboard-header">
    <div class="container">
      <h1 class="dashboard-title">üî• Kitchen Dashboard</h1>
      <p class="dashboard-subtitle">Monitor and manage incoming orders in real-time</p>
    </div>
  </div>

  <div class="container">
    <!-- Stats Row -->
    <div class="stats-row">
      <div class="row">
        <div class="col-md-3 col-6">
          <div class="stat-card">
            <span class="stat-number" id="pendingCount">0</span>
            <span class="stat-label">Pending</span>
          </div>
        </div>
        <div class="col-md-3 col-6">
          <div class="stat-card">
            <span class="stat-number" id="preparingCount">0</span>
            <span class="stat-label">Preparing</span>
          </div>
        </div>
        <div class="col-md-3 col-6">
          <div class="stat-card">
            <span class="stat-number" id="readyCount">0</span>
            <span class="stat-label">Ready</span>
          </div>
        </div>
        <div class="col-md-3 col-6">
          <div class="stat-card">
            <span class="stat-number" id="totalCount">0</span>
            <span class="stat-label">Total Orders</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Filter Tabs -->
    <div class="filter-tabs">
      <button class="filter-tab active" onclick="filterOrders('all')">All Orders</button>
      <button class="filter-tab" onclick="filterOrders('pending')">Pending</button>
      <button class="filter-tab" onclick="filterOrders('preparing')">Preparing</button>
      <button class="filter-tab" onclick="filterOrders('ready')">Ready</button>
    </div>

    <!-- Orders Container -->
    <div id="ordersContainer">
      <div class="no-orders">
        <div class="no-orders-icon">üçΩÔ∏è</div>
        <h3>No Orders Yet</h3>
        <p>Waiting for new orders from waiters...</p>
        <small class="text-muted">Orders will appear here automatically when submitted</small>
      </div>
    </div>
  </div>

  <div class="bamboo-decoration">üéã</div>

  <!-- Add Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Firebase Configuration (same as waiter.html)
    const firebaseConfig = {
      apiKey: "AIzaSyDY3XhrG-2Cj9y2QvW0RB9afjnW1k-NL6E",
      authDomain: "bamboo-15c88.firebaseapp.com",
      projectId: "bamboo-15c88",
      storageBucket: "bamboo-15c88.firebasestorage.app",
      messagingSenderId: "491968003258",
      appId: "1:491968003258:web:903605a044306b45745683",
      measurementId: "G-B99VR1M772",
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // Firestore collections
    const foodOrdersCollection = db.collection("food_orders");
    const cakeOrdersCollection = db.collection("cake_orders");

    // State
    let orders = {};
    let currentFilter = 'all';
    let soundEnabled = true;
    let lastOrderCount = 0;
    let knownOrderIds = new Set();

    // Connection status
    function showConnectionStatus(message, isError = false) {
      const existingStatus = document.querySelector('.connection-status');
      if (existingStatus) {
        existingStatus.remove();
      }

      const statusDiv = document.createElement('div');
      statusDiv.className = `connection-status ${isError ? 'error' : ''}`;
      statusDiv.innerHTML = `<i class="bi bi-${isError ? 'exclamation-triangle' : 'wifi'} me-2"></i>${message}`;
      
      document.body.appendChild(statusDiv);
      
      setTimeout(() => {
        if (statusDiv.parentNode) {
          statusDiv.style.opacity = '0';
          setTimeout(() => statusDiv.remove(), 500);
        }
      }, 3000);
    }

    // Fetch orders from Firestore
    async function fetchOrdersFromFirestore() {
      try {
        const [foodSnapshot, cakeSnapshot] = await Promise.all([
          foodOrdersCollection.orderBy('timestamp', 'desc').get(),
          cakeOrdersCollection.orderBy('timestamp', 'desc').get()
        ]);

        const newOrders = {};
        
        // Process food orders
        foodSnapshot.forEach(doc => {
          const data = doc.data();
          const orderId = doc.id;
          
          newOrders[orderId] = {
            id: orderId,
            docId: doc.id,
            table: data.table,
            items: data.items,
            total: data.total,
            status: data.status || 'pending',
            timestamp: data.timestamp,
            waiterSubmitted: data.waiterSubmitted,
            type: 'food',
            isNew: !knownOrderIds.has(orderId) && data.status === 'pending'
          };
          
          knownOrderIds.add(orderId);
        });

        // Process cake orders
        cakeSnapshot.forEach(doc => {
          const data = doc.data();
          const orderId = doc.id;
          
          newOrders[orderId] = {
            id: orderId,
            docId: doc.id,
            table: data.table,
            items: data.items,
            total: data.total,
            status: data.status || 'pending',
            timestamp: data.timestamp,
            waiterSubmitted: data.waiterSubmitted,
            type: 'cake',
            isNew: !knownOrderIds.has(orderId) && data.status === 'pending'
          };
          
          knownOrderIds.add(orderId);
        });

        // Check for new orders
        const currentOrderCount = Object.keys(newOrders).length;
        const newOrdersDetected = Object.values(newOrders).some(order => order.isNew);
        
        if (newOrdersDetected && lastOrderCount > 0) {
          const newOrdersList = Object.values(newOrders).filter(order => order.isNew);
          newOrdersList.forEach(order => {
            showNewOrderAlert(order.table, order.type);
            playNotificationSound();
          });
        }
        
        lastOrderCount = currentOrderCount;
        orders = newOrders;
        
        updateStats();
        renderOrders();
        
        showConnectionStatus('Connected - Orders synced');
        
      } catch (error) {
        console.error('Error fetching orders:', error);
        showConnectionStatus('Connection error - Retrying...', true);
      }
    }

    // Update order status in Firestore
    async function updateOrderStatus(orderId, newStatus) {
      try {
        const order = orders[orderId];
        if (!order) return;

        const collection = order.type === 'food' ? foodOrdersCollection : cakeOrdersCollection;
        
        await collection.doc(order.docId).update({
          status: newStatus,
          [`${newStatus}At`]: new Date().toISOString()
        });

        // Update local state
        order.status = newStatus;
        order.isNew = false;

        updateStats();
        renderOrders();
        
        console.log(`Order ${orderId} status updated to ${newStatus}`);
        
      } catch (error) {
        console.error('Error updating order status:', error);
        alert('Failed to update order status. Please try again.');
      }
    }

    function showNewOrderAlert(tableNumber, orderType) {
      // Remove existing alert if any
      const existingAlert = document.querySelector('.new-order-alert');
      if (existingAlert) {
        existingAlert.remove();
      }

      // Create new alert
      const alert = document.createElement('div');
      alert.className = 'new-order-alert';
      alert.innerHTML = `
        <i class="bi bi-bell-fill me-2"></i>
        <strong>New ${orderType.toUpperCase()} Order!</strong> Table ${tableNumber}
      `;
      
      document.body.appendChild(alert);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 5000);
    }

    function playNotificationSound() {
      if (!soundEnabled) return;
      
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (error) {
        console.log('Audio notification not available');
      }
    }

    function renderOrders() {
      const container = document.getElementById('ordersContainer');
      const orderEntries = Object.entries(orders);
      
      if (orderEntries.length === 0) {
        container.innerHTML = `
          <div class="no-orders">
            <div class="no-orders-icon">üçΩÔ∏è</div>
            <h3>No Orders Yet</h3>
            <p>Waiting for new orders from waiters...</p>
            <small class="text-muted">Orders will appear here automatically when submitted</small>
          </div>
        `;
        return;
      }

      let ordersHtml = '';
      
      // Filter orders based on current filter
      const filteredOrders = orderEntries.filter(([id, order]) => {
        return currentFilter === 'all' || order.status === currentFilter;
      });

      if (filteredOrders.length === 0) {
        container.innerHTML = `
          <div class="no-orders">
            <div class="no-orders-icon">üìã</div>
            <h3>No ${currentFilter.charAt(0).toUpperCase() + currentFilter.slice(1)} Orders</h3>
            <p>No orders match the current filter.</p>
          </div>
        `;
        return;
      }

      // Sort orders by timestamp (newest first)
      filteredOrders.sort(([,a], [,b]) => new Date(b.timestamp) - new Date(a.timestamp));

      filteredOrders.forEach(([orderId, order]) => {
        ordersHtml += createOrderCard(orderId, order);
      });
      
      container.innerHTML = ordersHtml;
    }

    function createOrderCard(orderId, order) {
      const timestamp = new Date(order.timestamp);
      const timeDiff = Math.floor((Date.now() - timestamp.getTime()) / (1000 * 60));
      const timeAgo = timeDiff === 0 ? 'Just now' : `${timeDiff} mins ago`;
      
      let itemsHtml = '';
      Object.entries(order.items).forEach(([itemName, itemData]) => {
        const emoji = getItemEmoji(itemName);
        itemsHtml += `
          <div class="order-item">
            <span class="item-name">${emoji} ${itemName}</span>
            <span class="item-quantity">√ó${itemData.qty}</span>
            <span class="item-price">‚Çπ${itemData.qty * itemData.price}</span>
          </div>
        `;
      });

      const statusClass = `status-${order.status}`;
      const newOrderClass = order.isNew ? 'new-order' : '';
      const orderTypeIcon = order.type === 'cake' ? 'üç∞' : 'üçΩÔ∏è';
      
      let buttonHtml = '';
      if (order.status === 'pending') {
        buttonHtml = `
          <div class="order-actions">
            <button class="status-btn" onclick="updateStatus('${orderId}')">
              <i class="bi bi-play-circle me-2"></i>Start Preparing
            </button>
            <button class="cancel-btn" onclick="cancelOrder('${orderId}')">
              <i class="bi bi-x-circle me-2"></i>Cancel
            </button>
          </div>
        `;
      } else if (order.status === 'preparing') {
        buttonHtml = `
          <div class="order-actions">
            <button class="status-btn preparing" onclick="updateStatus('${orderId}')">
              <i class="bi bi-check-circle me-2"></i>Mark as Ready
            </button>
          </div>
        `;
      }

      return `
        <div class="order-card ${newOrderClass}" data-status="${order.status}" id="${orderId}">
          <div class="order-header">
            <div class="table-info">
              <div class="table-number">
                <i class="bi bi-table"></i>
                Table ${order.table} ${orderTypeIcon}
                <small class="badge bg-secondary ms-2">${order.type.toUpperCase()}</small>
              </div>
              <div class="order-time">
                <i class="bi bi-clock"></i>
                ${timestamp.toLocaleTimeString()} - ${timeAgo}
              </div>
            </div>
            <span class="status-badge ${statusClass}" id="status-${orderId}">
              ${order.status.charAt(0).toUpperCase() + order.status.slice(1)}
            </span>
          </div>

          <div class="order-items">
            ${itemsHtml}
          </div>

          <div class="order-total">
            Total: ‚Çπ${order.total}
          </div>

          ${buttonHtml}
        </div>
      `;
    }

    function getItemEmoji(itemName) {
      const emojiMap = {
        'chicken': 'üçó',
        'biryani': 'üçõ',
        'rice': 'üçö',
        'pasta': 'üçù',
        'pizza': 'üçï',
        'soup': 'üçú',
        'momos': 'ü•ü',
        'salad': 'ü•ó',
        'prawn': 'üç§',
        'mojito': 'üçπ',
        'shake': 'ü•§',
        'coffee': '‚òï',
        'thupka': 'üç≤',
        'cake': 'üç∞',
        'forest': 'üç∞',
        'chocolate': 'üç´',
        'vanilla': 'üç¶',
        'strawberry': 'üçì',
        'cream': 'ü•õ',
        'brownie': 'üç´',
        'cheese': 'üßÄ'
      };

      const lowerName = itemName.toLowerCase();
      for (const [key, emoji] of Object.entries(emojiMap)) {
        if (lowerName.includes(key)) {
          return emoji;
        }
      }
      return 'üçΩÔ∏è'; // Default emoji
    }

    async function updateStatus(orderId) {
      const order = orders[orderId];
      if (!order) return;

      const card = document.getElementById(orderId);
      const badge = document.getElementById(`status-${orderId}`);
      const button = card.querySelector('.status-btn');

      // Show loading state
      if (button) {
        button.disabled = true;
        button.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Updating...';
      }

      try {
        if (order.status === 'pending') {
          await updateOrderStatus(orderId, 'preparing');

          badge.className = 'status-badge status-preparing';
          badge.innerText = 'Preparing';

          if (button) {
            button.innerHTML = '<i class="bi bi-check-circle me-2"></i>Mark as Ready';
            button.className = 'status-btn preparing';
            button.disabled = false;
          }

          // Add cooking animation
          card.style.background = 'linear-gradient(45deg, #fff 25%, #f8f9fa 25%, #f8f9fa 50%, #fff 50%, #fff 75%, #f8f9fa 75%)';
          card.style.backgroundSize = '20px 20px';
          card.style.animation = 'slide 2s linear infinite';
          card.classList.remove('new-order');

        } else if (order.status === 'preparing') {
          await updateOrderStatus(orderId, 'ready');

          badge.className = 'status-badge status-ready';
          badge.innerText = 'Ready';

          const actionsContainer = card.querySelector('.order-actions');
          if (actionsContainer) actionsContainer.remove();

          // Add completion effect
          card.style.background = 'white';
          card.style.animation = 'none';
          card.style.border = '2px solid #28a745';

          // Add ready notification
          const readyNotification = document.createElement('div');
          readyNotification.className = 'alert alert-success animate__animated animate__bounceIn';
          readyNotification.innerHTML = '<strong>üéâ Order Ready!</strong> This order is ready to be served.';
          readyNotification.style.marginTop = '1rem';
          card.appendChild(readyNotification);
        }
        
      } catch (error) {
        console.error('Error updating status:', error);
        if (button) {
          button.disabled = false;
          button.innerHTML = order.status === 'pending' ? 
            '<i class="bi bi-play-circle me-2"></i>Start Preparing' :
            '<i class="bi bi-check-circle me-2"></i>Mark as Ready';
        }
      }
    }

    // Add cancel order function
    async function cancelOrder(orderId) {
      const order = orders[orderId];
      if (!order) return;
      if (!confirm('Are you sure you want to cancel this order?')) return;

      const collection = order.type === 'food' ? foodOrdersCollection : cakeOrdersCollection;
      try {
        await collection.doc(order.docId).update({
          status: 'cancelled',
          cancelledAt: new Date().toISOString()
        });
        order.status = 'cancelled';
        order.isNew = false;
        updateStats();
        renderOrders();
        showConnectionStatus('Order cancelled');
      } catch (error) {
        alert('Failed to cancel order. Please try again.');
      }
    }

    function updateStats() {
      const pendingOrders = Object.values(orders).filter(o => o.status === 'pending').length;
      const preparingOrders = Object.values(orders).filter(o => o.status === 'preparing').length;
      const readyOrders = Object.values(orders).filter(o => o.status === 'ready').length;
      const totalOrders = Object.keys(orders).length;

      document.getElementById('pendingCount').textContent = pendingOrders;
      document.getElementById('preparingCount').textContent = preparingOrders;
      document.getElementById('readyCount').textContent = readyOrders;
      document.getElementById('totalCount').textContent = totalOrders;
    }

    function filterOrders(filter) {
      const tabs = document.querySelectorAll('.filter-tab');
      
      // Update active tab
      tabs.forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');
      
      currentFilter = filter;
      renderOrders();
    }

    // Sound toggle functionality
    function toggleSound() {
      soundEnabled = !soundEnabled;
      
      const soundButton = document.getElementById('soundToggle');
      if (soundButton) {
        soundButton.innerHTML = soundEnabled ? 
          '<i class="bi bi-volume-up me-2"></i>Sound On' : 
          '<i class="bi bi-volume-mute me-2"></i>Sound Off';
        soundButton.className = soundEnabled ? 
          'btn btn-success btn-sm' : 
          'btn btn-secondary btn-sm';
      }
    }

    // Add sound toggle button to header
    function addSoundToggle() {
      const header = document.querySelector('.dashboard-header .container');
      const soundButton = document.createElement('button');
      soundButton.id = 'soundToggle';
      soundButton.onclick = toggleSound;
      soundButton.className = soundEnabled ? 'btn btn-success btn-sm' : 'btn btn-secondary btn-sm';
      soundButton.innerHTML = soundEnabled ?
        '<i class="bi bi-volume-up me-2"></i>Sound On' :
        '<i class="bi bi-volume-mute me-2"></i>Sound Off';

      // Responsive position: desktop absolute, mobile fixed
      soundButton.style.cssText = `
        position: absolute;
        top: 3.5rem;
        right: 1rem;
        z-index: 10;
      `;
      header.style.position = 'relative';
      header.appendChild(soundButton);

      // Mobile: move to fixed position at bottom right
      function updateSoundBtnPosition() {
        if (window.innerWidth <= 768) {
          soundButton.style.position = 'fixed';
          soundButton.style.top = '';
          soundButton.style.right = '1rem';
          soundButton.style.bottom = '1rem';
          soundButton.style.left = '';
          soundButton.style.zIndex = '1002';
        } else {
          soundButton.style.position = 'absolute';
          soundButton.style.top = '3.5rem';
          soundButton.style.right = '1rem';
          soundButton.style.bottom = '';
          soundButton.style.left = '';
          soundButton.style.zIndex = '10';
        }
      }
      updateSoundBtnPosition();
      window.addEventListener('resize', updateSoundBtnPosition);
    }

    // Real-time listener for orders
    function setupRealtimeListeners() {
      // Listen to food orders
      foodOrdersCollection.orderBy('timestamp', 'desc').onSnapshot(
        (snapshot) => {
          console.log('Food orders updated');
          fetchOrdersFromFirestore();
        },
        (error) => {
          console.error('Error listening to food orders:', error);
          showConnectionStatus('Food orders sync error', true);
        }
      );

      // Listen to cake orders
      cakeOrdersCollection.orderBy('timestamp', 'desc').onSnapshot(
        (snapshot) => {
          console.log('Cake orders updated');
          fetchOrdersFromFirestore();
        },
        (error) => {
          console.error('Error listening to cake orders:', error);
          showConnectionStatus('Cake orders sync error', true);
        }
      );
    }

    // Add cooking animation keyframes
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slide {
        0% { background-position: 0 0; }
        100% { background-position: 40px 40px; }
      }
    `;
    document.head.appendChild(style);

    // Initialize
    document.addEventListener('DOMContentLoaded', async function() {
      showConnectionStatus('Connecting to database...');
      
      try {
        await fetchOrdersFromFirestore();
        setupRealtimeListeners();
        addSoundToggle();
        
        // Update time stamps every minute
        setInterval(() => {
          renderOrders();
        }, 60000);
        
      } catch (error) {
        console.error('Initialization error:', error);
        showConnectionStatus('Failed to connect to database', true);
      }
    });

    // Make functions globally available
    window.updateStatus = updateStatus;
    window.filterOrders = filterOrders;
    window.toggleSound = toggleSound;
    window.cancelOrder = cancelOrder;

    // Add keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Press 'R' to refresh orders
      if (e.key === 'r' || e.key === 'R') {
        if (!e.ctrlKey && !e.metaKey) {
          fetchOrdersFromFirestore();
          e.preventDefault();
        }
      }
      
      // Press numbers 1-4 to filter orders
      if (e.key >= '1' && e.key <= '4') {
        const filters = ['all', 'pending', 'preparing', 'ready'];
        const filterIndex = parseInt(e.key) - 1;
        if (filterIndex < filters.length) {
          currentFilter = filters[filterIndex];
          document.querySelectorAll('.filter-tab').forEach((tab, index) => {
            tab.classList.toggle('active', index === filterIndex);
          });
          renderOrders();
          e.preventDefault();
        }
      }
    });

    // Get order summary for shift end
    window.getOrderSummary = function() {
      const totalOrders = Object.keys(orders).length;
      const completedOrders = Object.values(orders).filter(o => o.status === 'ready').length;
      const totalRevenue = Object.values(orders).reduce((sum, order) => sum + order.total, 0);
      
      const summary = {
        totalOrders,
        completedOrders,
        totalRevenue,
        averageOrderValue: totalOrders > 0 ? Math.round(totalRevenue / totalOrders) : 0,
        completionRate: totalOrders > 0 ? Math.round((completedOrders / totalOrders) * 100) : 0
      };
      
      console.log('Kitchen Summary:', summary);
      return summary;
    };

    // Emergency clear all orders function (for testing)
    window.clearAllOrders = async function() {
      if (!confirm('Are you sure you want to clear all orders? This cannot be undone.')) {
        return;
      }

      try {
        // Get all documents from both collections
        const [foodSnapshot, cakeSnapshot] = await Promise.all([
          foodOrdersCollection.get(),
          cakeOrdersCollection.get()
        ]);

        // Create batch delete operations
        const batch = db.batch();
        
        foodSnapshot.forEach(doc => {
          batch.delete(doc.ref);
        });
        
        cakeSnapshot.forEach(doc => {
          batch.delete(doc.ref);
        });

        // Execute batch delete
        await batch.commit();
        
        // Clear local state
        orders = {};
        knownOrderIds.clear();
        lastOrderCount = 0;
        
        updateStats();
        renderOrders();
        
        showConnectionStatus('All orders cleared successfully!');
        
      } catch (error) {
        console.error('Error clearing orders:', error);
        showConnectionStatus('Failed to clear orders', true);
      }
    };

    // Connection health check
    function checkConnectionHealth() {
      db.enableNetwork().then(() => {
        console.log('Database connection is healthy');
      }).catch((error) => {
        console.error('Database connection issue:', error);
        showConnectionStatus('Connection issue detected', true);
      });
    }

    // Check connection every 30 seconds
    setInterval(checkConnectionHealth, 30000);

    // Handle offline/online events
    window.addEventListener('online', () => {
      showConnectionStatus('Back online - Reconnecting...');
      fetchOrdersFromFirestore();
    });

    window.addEventListener('offline', () => {
      showConnectionStatus('You are offline', true);
    });

    // Cleanup old completed orders (older than 24 hours)
    async function cleanupOldOrders() {
      try {
        const oneDayAgo = new Date();
        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
        
        const [foodSnapshot, cakeSnapshot] = await Promise.all([
          foodOrdersCollection
            .where('status', '==', 'ready')
            .where('timestamp', '<', oneDayAgo.toISOString())
            .get(),
          cakeOrdersCollection
            .where('status', '==', 'ready')
            .where('timestamp', '<', oneDayAgo.toISOString())
            .get()
        ]);

        const batch = db.batch();
        let deleteCount = 0;

        foodSnapshot.forEach(doc => {
          batch.delete(doc.ref);
          deleteCount++;
        });

        cakeSnapshot.forEach(doc => {
          batch.delete(doc.ref);
          deleteCount++;
        });

        if (deleteCount > 0) {
          await batch.commit();
          console.log(`Cleaned up ${deleteCount} old orders`);
        }

      } catch (error) {
        console.error('Error during cleanup:', error);
      }
    }

    // Run cleanup every 4 hours
    setInterval(cleanupOldOrders, 4 * 60 * 60 * 1000);

    // Export functions for testing
    window.fetchOrdersFromFirestore = fetchOrdersFromFirestore;
    window.setupRealtimeListeners = setupRealtimeListeners;
  </script>
</body>
</html>
